#!/usr/bin/env python3
"""
GPG Signing and Verification System
Iusmorfos Framework - Digital Signature Infrastructure

Automated GPG signing for code authenticity verification with key management
and signature validation following security best practices.

Author: Iusmorfos Development Team
Created: 2024-01-15
Last Updated: 2024-01-15
Version: 1.0.0
"""

import json
import os
import sys
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union
import argparse
import logging
import tempfile
import shutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('security/gpg.log'),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

class GPGManager:
    \"\"\"
    GPG key management and signing system for code authenticity verification.\n    \n    Provides automated GPG key generation, file signing, signature verification,\n    and key distribution management following security best practices.\n    \"\"\"\n    \n    def __init__(self, base_path: Union[str, Path] = '.'):\n        \"\"\"Initialize GPG manager with repository path.\"\"\"\n        self.base_path = Path(base_path).resolve()\n        self.gpg_dir = self.base_path / '.gnupg'\n        self.keys_dir = self.base_path / 'security' / 'keys'\n        self.signatures_dir = self.base_path / 'security' / 'signatures'\n        self.gpg_config_file = self.base_path / 'security' / 'gpg_config.json'\n        \n        # Ensure directories exist\n        for directory in [self.gpg_dir, self.keys_dir, self.signatures_dir]:\n            directory.mkdir(parents=True, exist_ok=True, mode=0o700)\n        \n        self.gpg_binary = self._find_gpg_binary()\n        \n        logger.info(f\"Initialized GPG Manager for: {self.base_path}\")\n    \n    def _find_gpg_binary(self) -> str:\n        \"\"\"Find available GPG binary on the system.\"\"\"\n        possible_binaries = ['gpg', 'gpg2', '/usr/bin/gpg', '/usr/local/bin/gpg']\n        \n        for binary in possible_binaries:\n            if shutil.which(binary):\n                logger.debug(f\"Found GPG binary: {binary}\")\n                return binary\n        \n        logger.error(\"‚ùå GPG binary not found. Please install GnuPG.\")\n        raise FileNotFoundError(\"GPG binary not found\")\n    \n    def _run_gpg_command(self, args: List[str], input_data: Optional[str] = None) -> Tuple[str, str, int]:\n        \"\"\"Run GPG command with proper configuration.\"\"\"\n        cmd = [\n            self.gpg_binary,\n            '--homedir', str(self.gpg_dir),\n            '--batch',\n            '--yes'\n        ] + args\n        \n        try:\n            result = subprocess.run(\n                cmd,\n                input=input_data,\n                capture_output=True,\n                text=True,\n                timeout=60\n            )\n            \n            logger.debug(f\"GPG command: {' '.join(cmd)}\")\n            logger.debug(f\"Return code: {result.returncode}\")\n            \n            return result.stdout, result.stderr, result.returncode\n            \n        except subprocess.TimeoutExpired:\n            logger.error(\"GPG command timed out\")\n            return \"\", \"Command timed out\", -1\n        except Exception as e:\n            logger.error(f\"Error running GPG command: {e}\")\n            return \"\", str(e), -1\n    \n    def generate_key_pair(self, \n                         name: str = \"Iusmorfos Framework\",\n                         email: str = \"iusmorfos@example.com\",\n                         comment: str = \"Code signing key\",\n                         key_type: str = \"RSA\",\n                         key_length: int = 4096,\n                         expire_date: str = \"2y\") -> Optional[str]:\n        \"\"\"\n        Generate a new GPG key pair for code signing.\n        \n        Args:\n            name: Real name for the key\n            email: Email address for the key\n            comment: Comment for the key\n            key_type: Key algorithm (RSA, ECDSA, etc.)\n            key_length: Key length in bits\n            expire_date: Expiration date (e.g., \"2y\", \"never\")\n            \n        Returns:\n            Key ID if successful, None otherwise\n        \"\"\"\n        logger.info(f\"üîë Generating GPG key pair for {name} <{email}>...\")\n        \n        # Create key generation configuration\n        key_config = f\"\"\"\n%echo Generating a key for Iusmorfos Framework\nKey-Type: {key_type}\nKey-Length: {key_length}\nSubkey-Type: {key_type}\nSubkey-Length: {key_length}\nName-Real: {name}\nName-Comment: {comment}\nName-Email: {email}\nExpire-Date: {expire_date}\nPassphrase: \n%commit\n%echo Key generation complete\n        \".strip()\n        \n        stdout, stderr, returncode = self._run_gpg_command(\n            ['--generate-key'],\n            input_data=key_config\n        )\n        \n        if returncode == 0:\n            # Extract key ID from output\n            key_id = self._extract_key_id_from_output(stdout + stderr)\n            if key_id:\n                logger.info(f\"‚úÖ GPG key pair generated successfully: {key_id}\")\n                \n                # Save key configuration\n                self._save_key_config({\n                    'key_id': key_id,\n                    'name': name,\n                    'email': email,\n                    'comment': comment,\n                    'generated': datetime.now().isoformat(),\n                    'key_type': key_type,\n                    'key_length': key_length,\n                    'expire_date': expire_date\n                })\n                \n                return key_id\n            else:\n                logger.error(\"‚ùå Could not extract key ID from GPG output\")\n        else:\n            logger.error(f\"‚ùå Key generation failed: {stderr}\")\n        \n        return None\n    \n    def _extract_key_id_from_output(self, output: str) -> Optional[str]:\n        \"\"\"Extract key ID from GPG command output.\"\"\"\n        import re\n        \n        # Look for key ID patterns\n        patterns = [\n            r'key ([A-F0-9]{8,16}) marked as ultimately trusted',\n            r'gpg: key ([A-F0-9]{8,16}):',\n            r'key ID ([A-F0-9]{8,16})'\n        ]\n        \n        for pattern in patterns:\n            match = re.search(pattern, output, re.IGNORECASE)\n            if match:\n                return match.group(1)\n        \n        return None\n    \n    def _save_key_config(self, config: Dict[str, Union[str, int]]) -> None:\n        \"\"\"Save key configuration to file.\"\"\"\n        try:\n            with open(self.gpg_config_file, 'w') as f:\n                json.dump(config, f, indent=2, sort_keys=True)\n            \n            logger.info(f\"‚úÖ Key configuration saved to: {self.gpg_config_file}\")\n            \n        except Exception as e:\n            logger.error(f\"Error saving key configuration: {e}\")\n    \n    def load_key_config(self) -> Optional[Dict[str, Union[str, int]]]:\n        \"\"\"Load key configuration from file.\"\"\"\n        if not self.gpg_config_file.exists():\n            return None\n        \n        try:\n            with open(self.gpg_config_file, 'r') as f:\n                config = json.load(f)\n            \n            logger.debug(f\"Loaded key configuration: {config.get('key_id', 'unknown')}\")\n            return config\n            \n        except Exception as e:\n            logger.error(f\"Error loading key configuration: {e}\")\n            return None\n    \n    def export_public_key(self, key_id: Optional[str] = None) -> Optional[str]:\n        \"\"\"\n        Export public key for distribution.\n        \n        Args:\n            key_id: Key ID to export, or None for default key\n            \n        Returns:\n            Path to exported public key file, or None if failed\n        \"\"\"\n        config = self.load_key_config()\n        if not key_id and config:\n            key_id = config.get('key_id')\n        \n        if not key_id:\n            logger.error(\"‚ùå No key ID provided and no default key found\")\n            return None\n        \n        logger.info(f\"üì§ Exporting public key: {key_id}\")\n        \n        stdout, stderr, returncode = self._run_gpg_command([\n            '--armor',\n            '--export',\n            key_id\n        ])\n        \n        if returncode == 0 and stdout:\n            # Save public key to file\n            public_key_file = self.keys_dir / f\"{key_id}_public.asc\"\n            \n            try:\n                with open(public_key_file, 'w') as f:\n                    f.write(stdout)\n                \n                logger.info(f\"‚úÖ Public key exported to: {public_key_file}\")\n                return str(public_key_file)\n                \n            except Exception as e:\n                logger.error(f\"Error saving public key: {e}\")\n        else:\n            logger.error(f\"‚ùå Public key export failed: {stderr}\")\n        \n        return None\n    \n    def sign_file(self, file_path: Union[str, Path], key_id: Optional[str] = None) -> Optional[str]:\n        \"\"\"\n        Sign a file with GPG.\n        \n        Args:\n            file_path: Path to file to sign\n            key_id: Key ID to use for signing, or None for default key\n            \n        Returns:\n            Path to signature file, or None if failed\n        \"\"\"\n        file_path = Path(file_path)\n        \n        if not file_path.exists():\n            logger.error(f\"‚ùå File not found: {file_path}\")\n            return None\n        \n        config = self.load_key_config()\n        if not key_id and config:\n            key_id = config.get('key_id')\n        \n        if not key_id:\n            logger.error(\"‚ùå No key ID provided and no default key found\")\n            return None\n        \n        logger.info(f\"‚úçÔ∏è  Signing file: {file_path}\")\n        \n        # Create signature file path\n        signature_file = self.signatures_dir / f\"{file_path.name}.sig\"\n        \n        stdout, stderr, returncode = self._run_gpg_command([\n            '--armor',\n            '--detach-sign',\n            '--local-user', key_id,\n            '--output', str(signature_file),\n            str(file_path)\n        ])\n        \n        if returncode == 0:\n            logger.info(f\"‚úÖ File signed successfully: {signature_file}\")\n            return str(signature_file)\n        else:\n            logger.error(f\"‚ùå File signing failed: {stderr}\")\n        \n        return None\n    \n    def verify_signature(self, file_path: Union[str, Path], \n                        signature_path: Optional[Union[str, Path]] = None) -> bool:\n        \"\"\"\n        Verify a file's GPG signature.\n        \n        Args:\n            file_path: Path to the original file\n            signature_path: Path to signature file, or None to auto-detect\n            \n        Returns:\n            True if signature is valid, False otherwise\n        \"\"\"\n        file_path = Path(file_path)\n        \n        if not file_path.exists():\n            logger.error(f\"‚ùå File not found: {file_path}\")\n            return False\n        \n        if signature_path is None:\n            signature_path = self.signatures_dir / f\"{file_path.name}.sig\"\n        else:\n            signature_path = Path(signature_path)\n        \n        if not signature_path.exists():\n            logger.error(f\"‚ùå Signature file not found: {signature_path}\")\n            return False\n        \n        logger.info(f\"üîç Verifying signature for: {file_path}\")\n        \n        stdout, stderr, returncode = self._run_gpg_command([\n            '--verify',\n            str(signature_path),\n            str(file_path)\n        ])\n        \n        if returncode == 0:\n            logger.info(f\"‚úÖ Signature verification successful\")\n            return True\n        else:\n            logger.error(f\"‚ùå Signature verification failed: {stderr}\")\n            return False\n    \n    def sign_critical_files(self) -> Dict[str, Optional[str]]:\n        \"\"\"\n        Sign all critical files in the repository.\n        \n        Returns:\n            Dictionary mapping file paths to signature paths (or None if failed)\n        \"\"\"\n        critical_files = [\n            'src/config.py',\n            'src/external_validation.py',\n            'src/robustness.py',\n            'app/streamlit_app.py',\n            'requirements.txt',\n            'Dockerfile',\n            'README.md',\n            'REPRODUCIBILITY.md',\n            'ro-crate-metadata.json'\n        ]\n        \n        logger.info(f\"üìù Signing {len(critical_files)} critical files...\")\n        \n        results = {}\n        \n        for file_path in critical_files:\n            full_path = self.base_path / file_path\n            if full_path.exists():\n                signature_path = self.sign_file(full_path)\n                results[file_path] = signature_path\n                if signature_path:\n                    logger.debug(f\"‚úÖ Signed: {file_path}\")\n                else:\n                    logger.warning(f\"‚ö†Ô∏è  Failed to sign: {file_path}\")\n            else:\n                logger.warning(f\"‚ö†Ô∏è  File not found: {file_path}\")\n                results[file_path] = None\n        \n        successful_signatures = sum(1 for sig in results.values() if sig is not None)\n        logger.info(f\"‚úÖ Signed {successful_signatures}/{len(critical_files)} files\")\n        \n        return results\n    \n    def verify_all_signatures(self) -> Dict[str, bool]:\n        \"\"\"\n        Verify all existing signatures in the repository.\n        \n        Returns:\n            Dictionary mapping file paths to verification results\n        \"\"\"\n        logger.info(\"üîç Verifying all GPG signatures...\")\n        \n        results = {}\n        signature_files = list(self.signatures_dir.glob('*.sig'))\n        \n        for signature_file in signature_files:\n            # Determine original file name\n            original_name = signature_file.name.replace('.sig', '')\n            \n            # Try to find the original file\n            possible_paths = [\n                self.base_path / original_name,\n                self.base_path / 'src' / original_name,\n                self.base_path / 'app' / original_name,\n                self.base_path / 'config' / original_name\n            ]\n            \n            original_file = None\n            for path in possible_paths:\n                if path.exists():\n                    original_file = path\n                    break\n            \n            if original_file:\n                is_valid = self.verify_signature(original_file, signature_file)\n                results[str(original_file.relative_to(self.base_path))] = is_valid\n            else:\n                logger.warning(f\"‚ö†Ô∏è  Original file not found for signature: {signature_file}\")\n                results[original_name] = False\n        \n        successful_verifications = sum(1 for valid in results.values() if valid)\n        total_signatures = len(results)\n        \n        logger.info(f\"üìä Verification Summary: {successful_verifications}/{total_signatures} signatures valid\")\n        \n        return results\n    \n    def create_signed_release(self, version: str) -> Optional[str]:\n        \"\"\"\n        Create a signed release archive.\n        \n        Args:\n            version: Version string for the release\n            \n        Returns:\n            Path to signed release archive, or None if failed\n        \"\"\"\n        logger.info(f\"üì¶ Creating signed release for version {version}...\")\n        \n        # Create temporary directory for release preparation\n        with tempfile.TemporaryDirectory() as temp_dir:\n            temp_path = Path(temp_dir)\n            release_dir = temp_path / f\"iusmorfos-{version}\"\n            \n            # Copy repository contents (excluding .git and temp files)\n            import shutil\n            \n            def ignore_patterns(dir_name, contents):\n                ignored = []\n                for item in contents:\n                    if item.startswith('.git') or item == '__pycache__' or item.endswith('.pyc'):\n                        ignored.append(item)\n                return ignored\n            \n            shutil.copytree(self.base_path, release_dir, ignore=ignore_patterns)\n            \n            # Create release archive\n            archive_name = f\"iusmorfos-{version}\"\n            archive_path = self.base_path / f\"{archive_name}.tar.gz\"\n            \n            # Create tar.gz archive\n            import tarfile\n            \n            with tarfile.open(archive_path, 'w:gz') as tar:\n                tar.add(release_dir, arcname=archive_name)\n            \n            logger.info(f\"üì¶ Release archive created: {archive_path}\")\n            \n            # Sign the archive\n            signature_path = self.sign_file(archive_path)\n            \n            if signature_path:\n                logger.info(f\"‚úÖ Signed release created: {archive_path}\")\n                logger.info(f\"‚úÖ Signature file: {signature_path}\")\n                return str(archive_path)\n            else:\n                logger.error(\"‚ùå Failed to sign release archive\")\n        \n        return None\n    \n    def setup_gpg_infrastructure(self) -> bool:\n        \"\"\"\n        Set up complete GPG infrastructure for the repository.\n        \n        Returns:\n            True if successful, False otherwise\n        \"\"\"\n        try:\n            logger.info(\"üîß Setting up GPG infrastructure...\")\n            \n            # Check if key already exists\n            config = self.load_key_config()\n            \n            if config and config.get('key_id'):\n                logger.info(f\"üìã Using existing GPG key: {config['key_id']}\")\n                key_id = config['key_id']\n            else:\n                # Generate new key pair\n                key_id = self.generate_key_pair()\n                if not key_id:\n                    logger.error(\"‚ùå Failed to generate GPG key pair\")\n                    return False\n            \n            # Export public key\n            public_key_path = self.export_public_key(key_id)\n            if not public_key_path:\n                logger.error(\"‚ùå Failed to export public key\")\n                return False\n            \n            # Sign critical files\n            signature_results = self.sign_critical_files()\n            \n            # Create verification script\n            self._create_verification_script(key_id)\n            \n            # Create README for GPG usage\n            self._create_gpg_readme()\n            \n            logger.info(\"‚úÖ GPG infrastructure setup completed\")\n            logger.info(f\"üìã Public key available at: {public_key_path}\")\n            logger.info(\"üìã Run 'python security/gpg_signing.py verify-all' to verify signatures\")\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"‚ùå Error setting up GPG infrastructure: {e}\")\n            return False\n    \n    def _create_verification_script(self, key_id: str) -> None:\n        \"\"\"Create a verification script for end users.\"\"\"\n        script_content = f'''\n#!/bin/bash\n# GPG Signature Verification Script for Iusmorfos Framework\n# Generated on {datetime.now().isoformat()}\n\nset -e\n\necho \"üîç Iusmorfos Framework - GPG Signature Verification\"\necho \"=================================================\"\n\n# Check if GPG is installed\nif ! command -v gpg &> /dev/null; then\n    echo \"‚ùå GPG is not installed. Please install GnuPG.\"\n    exit 1\nfi\n\n# Import public key if not already imported\nif ! gpg --list-keys {key_id} &> /dev/null; then\n    echo \"üì• Importing Iusmorfos public key...\"\n    gpg --import security/keys/{key_id}_public.asc\nelse\n    echo \"‚úÖ Iusmorfos public key already imported\"\nfi\n\n# Verify signatures\necho \"\\nüîç Verifying file signatures...\"\n\nVERIFY_COUNT=0\nSUCCESS_COUNT=0\n\nfor sig_file in security/signatures/*.sig; do\n    if [ -f \"$sig_file\" ]; then\n        VERIFY_COUNT=$((VERIFY_COUNT + 1))\n        \n        # Extract original filename\n        base_name=$(basename \"$sig_file\" .sig)\n        \n        # Find original file\n        original_file=\"\"\n        for dir in . src app config; do\n            if [ -f \"$dir/$base_name\" ]; then\n                original_file=\"$dir/$base_name\"\n                break\n            fi\n        done\n        \n        if [ -n \"$original_file\" ]; then\n            echo -n \"Verifying $original_file... \"\n            if gpg --verify \"$sig_file\" \"$original_file\" &> /dev/null; then\n                echo \"‚úÖ VALID\"\n                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))\n            else\n                echo \"‚ùå INVALID\"\n            fi\n        else\n            echo \"‚ö†Ô∏è  Original file not found for $sig_file\"\n        fi\n    fi\ndone\n\necho \"\\nüìä Verification Summary:\"\necho \"   ‚úÖ Valid signatures: $SUCCESS_COUNT/$VERIFY_COUNT\"\n\nif [ $SUCCESS_COUNT -eq $VERIFY_COUNT ] && [ $VERIFY_COUNT -gt 0 ]; then\n    echo \"üéâ All signatures verified successfully!\"\n    exit 0\nelse\n    echo \"‚ùå Some signatures failed verification\"\n    exit 1\nfi\n        '''.strip()\n        \n        script_path = self.base_path / 'verify_signatures.sh'\n        \n        try:\n            with open(script_path, 'w') as f:\n                f.write(script_content)\n            \n            # Make executable\n            script_path.chmod(0o755)\n            \n            logger.info(f\"‚úÖ Verification script created: {script_path}\")\n            \n        except Exception as e:\n            logger.error(f\"Error creating verification script: {e}\")\n    \n    def _create_gpg_readme(self) -> None:\n        \"\"\"Create README for GPG usage.\"\"\"\n        readme_content = '''\n# GPG Signature Verification\n\nThis directory contains GPG signatures and public keys for verifying the authenticity of Iusmorfos Framework files.\n\n## Quick Verification\n\nRun the automated verification script:\n\n```bash\n./verify_signatures.sh\n```\n\n## Manual Verification\n\n1. Import the public key:\n```bash\ngpg --import security/keys/*_public.asc\n```\n\n2. Verify individual files:\n```bash\ngpg --verify security/signatures/filename.sig path/to/original/filename\n```\n\n## File Structure\n\n- `keys/`: Public keys for signature verification\n- `signatures/`: Detached GPG signatures for critical files\n- `gpg_config.json`: Key configuration metadata\n- `gpg.log`: GPG operation logs\n\n## Security Notes\n\n- All critical framework files are signed with GPG\n- Signatures use RSA-4096 keys for maximum security\n- Public keys are included in the repository for easy verification\n- Signature verification should be performed before using the framework\n\n## Trust Model\n\nThe Iusmorfos Framework uses a simple trust model:\n\n1. **Code Authenticity**: All critical files are GPG signed\n2. **Public Key Distribution**: Public keys distributed via repository\n3. **Verification Required**: Users should verify signatures before use\n4. **Release Signing**: All releases include signed archives\n\nFor questions about GPG signatures or key verification, see the main repository documentation.\n        '''.strip()\n        \n        readme_path = self.keys_dir / 'README.md'\n        \n        try:\n            with open(readme_path, 'w') as f:\n                f.write(readme_content)\n            \n            logger.info(f\"‚úÖ GPG README created: {readme_path}\")\n            \n        except Exception as e:\n            logger.error(f\"Error creating GPG README: {e}\")\n\n\ndef main():\n    \"\"\"Command-line interface for GPG operations.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Iusmorfos Framework - GPG Signing and Verification\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  %(prog)s setup           # Set up complete GPG infrastructure\n  %(prog)s sign-all        # Sign all critical files\n  %(prog)s verify-all      # Verify all signatures\n  %(prog)s create-release  # Create signed release archive\n  %(prog)s --help          # Show this help message\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        'command',\n        choices=['setup', 'sign-all', 'verify-all', 'create-release'],\n        help='Command to execute'\n    )\n    \n    parser.add_argument(\n        '--path',\n        type=str,\n        default='.',\n        help='Base path to repository (default: current directory)'\n    )\n    \n    parser.add_argument(\n        '--version',\n        type=str,\n        help='Version string for release creation'\n    )\n    \n    parser.add_argument(\n        '--verbose', '-v',\n        action='store_true',\n        help='Enable verbose logging'\n    )\n    \n    args = parser.parse_args()\n    \n    # Set logging level\n    if args.verbose:\n        logger.setLevel(logging.DEBUG)\n    \n    # Initialize GPG manager\n    gpg_manager = GPGManager(args.path)\n    \n    # Execute command\n    success = False\n    \n    if args.command == 'setup':\n        success = gpg_manager.setup_gpg_infrastructure()\n    elif args.command == 'sign-all':\n        results = gpg_manager.sign_critical_files()\n        success = any(sig is not None for sig in results.values())\n    elif args.command == 'verify-all':\n        results = gpg_manager.verify_all_signatures()\n        success = all(results.values()) if results else False\n    elif args.command == 'create-release':\n        if not args.version:\n            logger.error(\"‚ùå --version required for create-release command\")\n            sys.exit(1)\n        archive_path = gpg_manager.create_signed_release(args.version)\n        success = archive_path is not None\n    else:\n        logger.error(f\"Unknown command: {args.command}\")\n        sys.exit(1)\n    \n    # Exit with appropriate code\n    sys.exit(0 if success else 1)\n\n\nif __name__ == '__main__':\n    main()\n